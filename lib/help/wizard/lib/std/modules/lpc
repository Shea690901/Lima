Module LPC:
These functions are available with the following lines of code:

#include <mudlib.h>
inherit M_LPC;


len(a) -- returns the length of any aggregate type, be it the
length of a string, the number of elements in an array, or
the number of entries in a mapping.

clean_array(arr) -- returns a version of arr with duplicated entries
removed.

exclude_array(arr, start, finish) -- returns a copy of arr with the
range of elements sliced out.  Ie, the size of the array shrinks.

cmp(u, v) -- returns whether u and v are equivolent.  This is about
the same as using the equivolence operator (==), but will return true
in cases where == does not, such as when comparing 2 empty arrays.
Logically 2 empty arrays should be equivolent, but aren't with ==.
cmp() knows they are.  This is mainly useful when you want to compare
mappings and arrays.

choice(a) -- Returns a random element of a, if a is an aggregate
type. (A string, array or mapping)

min(a) -- Returns the smallest element of an aggregate type. (string, array,
or mapping)

max(a) -- Returns the largest element of a, where a is a string,
array or mapping.

decompose(arr) -- Takes any arrays that are elements in arr and merges
all of its elements as elements of arr.  Eg, decompose(({1,({2,3,}),4}))
will return: ({1,2,3,4}).  The algorithm is not recursive, so if any of
the arrays have arrays in them, those arrays remain intact.  Eg,
decompose( ({1,({({2,3}),4}),5}) )  returns:({1,({2,3}),4,5}).  

eval(s) -- evaluates the string s as an LPC value.  Eg, if you have a string someone
typed in: "({1,2,3,4})"  eval returns the actual array ({1,2,3,4}).

insert(item, array, where) -- inserts item into the array, after
the index specified in where.
