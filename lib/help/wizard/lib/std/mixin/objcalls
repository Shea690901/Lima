Module ObjCalls:
These functions are available with the following lines of code:

#include <mudlib.h>
inherit M_OBJCALLS;




base_name(obj) -- returns the file name that obj was created from,
without the ".c" extention.  Eg, base_name(this_player()) will return
"/std/dev" for wizards.

compare_objects(ob1, ob2) -- returns 1 if the objects are different
occurances of the same object in the exact same state.  Eg, if you
pass 2 candles, but 1 is lit and the other isn't, this is false.  If
both are lit, compare_objects() is true.

count(obj) -- returns the number of exact copies of obj as determined by
compare_objects() that are in obj's environment. obj defaults to the
calling object if not specified.

duplicatep(obj) -- returns 1 for any obj where obj has a duplicate in
its environment, and obj isn't considered the FIRST object.

deep_all_inv(obj) -- returns an array containing a list of all objects
in obj's inventory, recusively.  Ie, deep_all_inv() will not only find
a backpack on a player, but also all of the objects in that backpack.

deep_useful_inv(obj) -- same as deep_all_inv() but filters out objects
that are enclosed in containers, or otherwise not useable.

find_object_or_load(file) -- same as find_object(file), except if the
object is not found, an attempt is made to load the object then try to
find it again.  

get_object(str) -- Tries to convert a string into an object.  It
understands "me" and "here", and then checks present() in the player's
inventory, then in the environment, then trys find_living(), then
find_object_or_load().  This is a pretty primitive parsing assist, and
if you're thinking of using it, discuss it with an admin, because
there's likely a better alternative, depending on your task.

immediatly_accessable(obj) -- Returns true if obj is accessable from
its environment.  (Ie, by picking it up.)

usable(obj, flag) -- Returns true if the player can "use" the object.
If a flag is given, useable tries to get the object first.  Usable in
this instance usually refers to in the player's inventory or on the
ground, unless obj defines a function called always_usable() that
returns non-zero.

inv_list(obj, flag) -- Returns a string that is a nice listing of the
objects in obj.  If a flag is given, objects that have not yet been
touched aren't printed.

owner(obj) -- returns the living object holding obj, or 0 if none exists.

target(s) -- Returns the inventory of the object refered to by s, as
well as the object if it's living.  I have no clue what good this
function is, or where it is used.

parse_object_ref(s) -- Converts s into the object it represents.  This
function is intended to be used as a parser for wizard commands that
refer to objects of various means (such as dest and trans).
Strings are of the form 'object' or 'object@environment' where
environment can also be of the for object@environment.  object may
also be of the form 'e(object)' which refers to the environment of
object.  object may also be prefixed with one of the following
symbols:
%  --> what follows names a player
$  --> what follows names an NPC
#  --> what follows is an ordinal value.  (eg, #3)
Eg: parse_object_ref("!key@%truilkan")  Will return an object with id
of "key" in player truilkan's inventory.
Eg: pased_object_ref("#3@here")  Returns the 4th object in the current
player's inventory.  (Remember, inventorys are stored in arrays, and
numbering of elements of an array starts at 0.)

objects() -- returns an array containing all of the objects loaded
and/or cloned on the mud.

find_monster(name) finds a monster (non-player) in objects()

find_monster_in_room(name, room) finds a non-player living in 
the room's all_inventory()
