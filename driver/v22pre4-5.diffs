diff -crN v22pre4/src/ChangeLog.beta v22pre5/src/ChangeLog.beta
*** v22pre4/src/ChangeLog.beta	Wed Apr  2 12:19:36 1997
--- v22pre5/src/ChangeLog.beta	Sun Apr  6 17:37:44 1997
***************
*** 1,4 ****
--- 1,12 ----
  ----------------------------------------------------------------------------
+ Wed Apr  2 13:31:44 EST 1997 (tim@wfn-shop.princeton.edu (Beek))
+ 	* raised patchlevel to v22pre5
+ 	* fixed leak in check_valid_path() [reported by Fermat]
+ 	* fixed crashers in function pointer add_actions() when the driver
+ 	  is run in -d -d mode [reported by Aragorn]
+ 	* ported back the socket close callback fix
+ 	* disabled #pragma optimize
+ 
  Tue Apr  1 23:53:07 EST 1997 (tim@wfn-shop.princeton.edu (Beek))
  	* raised patchlevel to v22pre4
          * Added Leslie@StyleGates' fix for a leak in REVERSIBLE_EXPLODE_STRING
diff -crN v22pre4/src/file.c v22pre5/src/file.c
*** v22pre4/src/file.c	Tue Apr  1 23:56:58 1997
--- v22pre5/src/file.c	Sun Apr  6 16:40:39 1997
***************
*** 169,183 ****
  	/*
  	 * If path ends with '/' or "/." remove it
  	 */
- #if 0 /* was WIN32 */
- 	if ((p = strrchr(temppath, '\\')) == 0)
- 	    p = temppath;
- 	if (p[0] == '\\' && ((p[1] == '.' && p[2] == '\0') || p[1] == '\0'))
- #else
  	if ((p = strrchr(temppath, '/')) == 0)
  	    p = temppath;
  	if (p[0] == '/' && ((p[1] == '.' && p[2] == '\0') || p[1] == '\0'))
- #endif
  	    *p = '\0';
      }
  
--- 169,177 ----
***************
*** 196,208 ****
  #endif
  	}
  	do_match = 1;
- #if 0 /* def WIN32 */
      } else if (*p != '\0' && strcmp(temppath, ".")) {
- 	if (*p == '\\' && *(p + 1) != '\0')
- #else
-     } else if (*p != '\0' && strcmp(temppath, ".")) {
  	if (*p == '/' && *(p + 1) != '\0')
- #endif
  	    p++;
  	v = allocate_empty_array(1);
  	encode_stat(&v->item[0], flags, p, &st);
--- 190,197 ----
***************
*** 898,903 ****
--- 887,893 ----
  	} else {
  	    extern svalue_t apply_ret_value;
  	    
+ 	    free_svalue(&apply_ret_value, "check_valid_path");
  	    apply_ret_value.type = T_STRING;
  	    apply_ret_value.subtype = STRING_MALLOC;
  	    path = apply_ret_value.u.string = string_copy(path, "check_valid_path");
diff -crN v22pre4/src/interpret.c v22pre5/src/interpret.c
*** v22pre4/src/interpret.c	Sat Mar  1 23:35:18 1997
--- v22pre5/src/interpret.c	Sun Apr  6 17:15:04 1997
***************
*** 5075,5081 ****
  
  void opcdump P1(char *, tfn)
  {
!     int ind, i, j, len, limit;
      char tbuf[SMALL_STRING_SIZE], *fn;
      FILE *fp;
      sort_elem_t ops[(BASE + 1) * (BASE + 1)];
--- 5075,5081 ----
  
  void opcdump P1(char *, tfn)
  {
!     int ind, i, j, len;
      char tbuf[SMALL_STRING_SIZE], *fn;
      FILE *fp;
      sort_elem_t ops[(BASE + 1) * (BASE + 1)];
diff -crN v22pre4/src/lex.c v22pre5/src/lex.c
*** v22pre4/src/lex.c	Sat Mar  1 23:35:19 1997
--- v22pre5/src/lex.c	Sun Apr  6 17:37:30 1997
***************
*** 873,879 ****
      { "save_binary", PRAGMA_SAVE_BINARY },
  #endif
      { "warnings", PRAGMA_WARNINGS },
!     { "optimize", PRAGMA_OPTIMIZE },
      { "show_error_context", PRAGMA_ERROR_CONTEXT },
      { 0, 0 }
  };
--- 873,879 ----
      { "save_binary", PRAGMA_SAVE_BINARY },
  #endif
      { "warnings", PRAGMA_WARNINGS },
!     { "optimize", 0 },
      { "show_error_context", PRAGMA_ERROR_CONTEXT },
      { 0, 0 }
  };
diff -crN v22pre4/src/patchlevel.h v22pre5/src/patchlevel.h
*** v22pre4/src/patchlevel.h	Wed Apr  2 13:21:21 1997
--- v22pre5/src/patchlevel.h	Wed Apr  2 13:31:37 1997
***************
*** 1 ****
! #define PATCH_LEVEL "v22pre4"
--- 1 ----
! #define PATCH_LEVEL "v22pre5"
diff -crN v22pre4/src/simulate.c v22pre5/src/simulate.c
*** v22pre4/src/simulate.c	Sat Mar  1 23:36:29 1997
--- v22pre5/src/simulate.c	Sun Apr  6 17:10:05 1997
***************
*** 1857,1863 ****
  	 * Now we have found a special sentence !
  	 */
  #ifdef DEBUG
! 	if (d_flag > 1)
  	    debug_message("Local command %s on /%s\n",
  			  s->function, s->ob->name);
  #endif
--- 1857,1863 ----
  	 * Now we have found a special sentence !
  	 */
  #ifdef DEBUG
! 	if (d_flag > 1 && !(s->flags & V_FUNCTION))
  	    debug_message("Local command %s on /%s\n",
  			  s->function, s->ob->name);
  #endif
***************
*** 2064,2070 ****
  
  	if ((*s)->ob == ob) {
  #ifdef DEBUG
! 	    if (d_flag > 1)
  		debug_message("--Unlinking sentence %s\n", (*s)->function);
  #endif
  	    tmp = *s;
--- 2064,2070 ----
  
  	if ((*s)->ob == ob) {
  #ifdef DEBUG
! 	    if (d_flag > 1 && !(s->flags & V_FUNCTION))
  		debug_message("--Unlinking sentence %s\n", (*s)->function);
  #endif
  	    tmp = *s;
diff -crN v22pre4/src/socket_efuns.c v22pre5/src/socket_efuns.c
*** v22pre4/src/socket_efuns.c	Sat Mar  1 23:36:36 1997
--- v22pre5/src/socket_efuns.c	Sun Apr  6 17:07:23 1997
***************
*** 1,3 ****
--- 1,4 ----
+ 
  /*
   * socket_efun.c -- socket efuns for MudOS.
   *    5-92 : Dwayne Fontenot (Jacques@TMI) : original coding.
***************
*** 939,946 ****
  	cc = OS_socket_write(lpc_socks[fd].fd, 
  			     lpc_socks[fd].w_buf + lpc_socks[fd].w_off,
  			     lpc_socks[fd].w_len);
! 	if (cc == -1)
  	    return;
  	lpc_socks[fd].w_off += cc;
  	lpc_socks[fd].w_len -= cc;
  	if (lpc_socks[fd].w_len != 0)
--- 940,954 ----
  	cc = OS_socket_write(lpc_socks[fd].fd, 
  			     lpc_socks[fd].w_buf + lpc_socks[fd].w_off,
  			     lpc_socks[fd].w_len);
! 	if (cc == -1) {
! 	    if (lpc_socks[fd].state == FLUSHING &&
! 		errno != EINTR) {
! 		/* give up on errors writing to closing sockets */
! 		lpc_socks[fd].flags &= ~S_BLOCKED;
! 		socket_close(fd, SC_FORCE | SC_FINAL_CLOSE);
! 	    }
  	    return;
+ 	}
  	lpc_socks[fd].w_off += cc;
  	lpc_socks[fd].w_len -= cc;
  	if (lpc_socks[fd].w_len != 0)
***************
*** 976,981 ****
--- 984,999 ----
      if (!(flags & SC_FORCE) && lpc_socks[fd].owner_ob != current_object)
  	return EESECURITY;
  
+     if (flags & SC_DO_CALLBACK) {
+ 	debug(8192, ("read_socket_handler: apply close callback\n"));
+ 	push_number(fd);
+ 	call_callback(fd, S_CLOSE_FP, 1);
+     }
+     
+     set_read_callback(fd, 0);
+     set_write_callback(fd, 0);
+     set_close_callback(fd, 0);
+ 
      if (lpc_socks[fd].flags & S_BLOCKED) {
  	/* Can't close now; we still have data to write.  Tell the mudlib
  	 * it is closed, but we really finish up later.
***************
*** 991,1006 ****
  	FREE(lpc_socks[fd].r_buf);
      if (lpc_socks[fd].w_buf != NULL)
  	FREE(lpc_socks[fd].w_buf);
- 
-     if (flags & SC_DO_CALLBACK) {
- 	debug(8192, ("read_socket_handler: apply close callback\n"));
- 	push_number(fd);
- 	call_callback(fd, S_CLOSE_FP, 1);
-     }
-     
-     set_read_callback(fd, 0);
-     set_write_callback(fd, 0);
-     set_close_callback(fd, 0);
  
      debug(8192, ("socket_close: closed fd %d\n", fd));
      return EESUCCESS;
--- 1009,1014 ----
