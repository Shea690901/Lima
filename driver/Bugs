If an include file doesn't end in a newline, something screws up in the
linked buffer code, causing odd compile errors.

-----

RUNTIME_LOADING needs -rdynamic passed in the link on some OS's?
(reported for a gcc-linux system; possibly a mixed a.out/elf?)

-----

btw.. did you know that the uids behaviour differs slightly from under Amylaar ?
In simulate.c there is a line that has a comment: /* FIXME - is this correct */
 - the line above this does something like  target->uid = my->uid
 Under Amylaar an object _never_ gives away its uid to another object, it always
 gives its euid. When I moved from Amy it took me a heck of a long time to
figure out why i was getting all these weird bugs.. then I discovered it and 
 made the simple patch. 
 I just thought I'd mention it as you might wanna give Amylaar uid behaviour
 when COMPAT_32 is defined..

-Pace

-----

The error for new(class undefined_class name, ...) could be better.
Currently it's a parse error.

-----

It is possible under some circumstances to get two entries for the same function into the function table.  I think it's related to #pragma no_strict_types allowing definitions in cases like the following:

int foo() {
    bar();
}

int bar() {
}

But I can't reproduce it.  It also causes odd inherit warnings like:

room/quest_room.c line 66: Warning convert_number() inherited from both
room/room.c and room/room.c using the definition in /room/room.c

-----

This gives the wrong error message:

unlock the door with the key
Trying interpretation: unlock:the:door:with:the:key:
Trying rule: OBJ with OBJ
  parse_rule
    parse_obj:
    Found noun: door
      parse_rule
      Matched literal: with
        parse_obj:
        Found noun: key
          parse_rule
            we_are_finished
            Trying can_unlock_obj_with_obj ...
            Trying can_unlock_obj_word_obj ...
            Trying can_verb_obj_word_obj ...
            Trying can_verb_rule ...
            Trying can_unlock_obj_with_obj ...
            Return value was: 1
            Trying direct_unlock_obj_with_obj ...
            Return value was: 1
            Trying indirect_unlock_obj_with_obj ...
            Return value was: 0
            You can't unlock the thing with that.
 
          exiting parse_rule ...
        parse_rule
        exiting parse_rule ...
        parse_rule
          we_are_finished
         Trying can_unlock_obj_with_obj ...
          Trying can_unlock_obj_word_obj ...
          Trying can_verb_obj_word_obj ...
          Trying can_verb_rule ...
          Trying can_unlock_obj_with_obj ...
          Return value was: 1
        exiting parse_rule ...
      Done trying to match OBJ
    parse_rule
    last match to error ...
    Changing last match.
      parse_obj:
      Found noun: key
        parse_rule
          we_are_finished
          Trying can_unlock_obj_with_obj ...
          Trying can_unlock_obj_word_obj ...
          Trying can_verb_obj_word_obj ...
          Trying can_verb_rule ...
          Trying can_unlock_obj_with_obj ...
          Return value was: 1
          Trying indirect_unlock_obj_with_obj ...
          Return value was: 0
          You can't unlock the thing with that.
 
        exiting parse_rule ...
      parse_rule
      exiting parse_rule ...
      parse_rule

        we_are_finished
        Trying can_unlock_obj_with_obj ...
        Trying can_unlock_obj_word_obj ...
        Trying can_verb_obj_word_obj ...
        Trying can_verb_rule ...
        Trying can_unlock_obj_with_obj ...
        Return value was: 1
        Have better match; aborting ...
      exiting parse_rule ...
    Done trying to match OBJ
    parse_rule
    Matched literal: with
      parse_obj:
      Found noun: key
        parse_rule
          we_are_finished
          Trying can_unlock_obj_with_obj ...
          Trying can_unlock_obj_word_obj ...
          Trying can_verb_obj_word_obj ...
          Trying can_verb_rule ...
          Trying can_unlock_obj_with_obj ...
          Return value was: 1
          Trying indirect_unlock_obj_with_obj ...
          Return value was: 0
          You can't unlock the thing with that.
 
        exiting parse_rule ...
      parse_rule
      exiting parse_rule ...
      parse_rule
        we_are_finished
        Trying can_unlock_obj_with_obj ...
        Trying can_unlock_obj_word_obj ...
        Trying can_verb_obj_word_obj ...
        Trying can_verb_rule ...
        Trying can_unlock_obj_with_obj ...
        Return value was: 1
        Have better match; aborting ...
      exiting parse_rule ...
    Done trying to match OBJ
    parse_rule
    last match to error ...
    Literal not found in forward search
    parse_rule
    last match to error ...
    Literal not found in forward search
    parse_rule
    Ran out of words to parse.
  Done trying to match OBJ
There is no door here.

-----

It still seems possible for regexp(explode(read_file(...), "\n"), ...) to
crash, but I can't reproduce it.

-----

#pragma optimize bug:

;; Function room_of
049d: local LV0
049f: ! 
04a0: || 0006 (04a7)
04a3: transfer_local LV0
04a5: objectp 
04a6: ! 
04a7: branch_when_zero 0003 (04ab)
04aa: return_zero 
04ab: branch 0007 (04b3)
04ae: local LV1
04b0: (void)assign_local LV0
04b2: break_point 
04b3: local LV0
04b5: environment 
04b7: local_lvalue LV1
04b9: assign 
04ba: bbranch_when_non_zero 000d (04ae)
04bd: transfer_local LV0
04bf: return 
04c0: return_zero 

object room_of(object obj) {
    object ob;
    if(!obj || !objectp(obj)) return 0;
    while(ob=environment(obj)) obj=ob;
    return obj;
}

-----

@ENDTEXT


ENDTEXT, "foo")

incorrectly protects the "'s with \'s, assuming it is inside the text block

-----

call_out() and efuns can be used to call #global_init#

-----

Various efuns which call valid_hide() don't realize it can error, causing
them to leak if master::valid_hide() throws an error.

-----

heart_beat() is not shadowable

-----

need a way to tell the driver to try reconnecting to the addr_server
after it has gone down and come back up (the addr_server).  maybe
the driver could just retry every now and then?

--john

-----

read_file() doesn't guarantee that a "/" is at the start of the filename
before passing to valid_read()...same problem might exist with
write_file(), read_bytes(), write_bytes(), didn't check yet

(ucs_brf@pip.shsu.edu)

Comment:
    This problem is rather common in the driver currently.  Internally,
    filenames have no leading '/'.  One should probably be added every time
    a filename is passed to the mudlib.

-----

hm, Linux apparently doesn't let you open a directory for reading. boggle.
so all the efuns that read from a file will screw up if you try
to use a dir as the file.  ack

ucs_brf@pip.shsu.edu

-----

    mixed a;
    do {} while (a = ({ a, "" }));

Profezzorn@TMI-2

Comment:
    It would be nice if things like this, where all the memory (VM too)
    is sucked up by a runaway program, didn't cause the driver to
    shutdown ("Out of memory").

### Nope, this evals out, need to do more work to make it run out of memory
	-Sym (note: which is not the same as if the driver errors with "Out
	of memory)

-----

Currently, binaries are not checked to see if they are out of date with
respect to the simul_efun object, causing wierd behavior of binaries of
the order of the simuls changes, and then a binary is loaded.

------

edit_source should check for the existence of a.out to see if compilation
succeeded.  The exit code of the compiler is correct alot, but not on
all systems.  Should probably use -o somefile instead of assuming a.out
as well.

-----

Line numbers get messed up when files don't end in a newline?

-----

Range/switch search should be binary, not linear. (in LPC->C)

-----

Probably need a test to see if bison's output actually compiles in
./build.Mudos;  on alot of AIX systems bison's use of alloca() fails.

-Beek

-------

The current implementation of swapping could use alot of work.  Swapping
an object in/out isn't that expensive CPU wise, and can save a decent amount
of memory.  The problem is that cloned programs can't swap, which disables
swapping for much of the mud ...

-Beek

-----

eval string s = "xyz"; s[1] = 0; return s + "foo";

Isn't handled right, since after s[1] = 0 the length is still 3.
Several possible ways to fix this:

(1) allow strings to contain zero, and nuke the buffer type (requires a
    number of mods like strcpy() -> memcpy() throughout the source)

(2) claim that assigning 0 to a char lvalue is a runtime error (the easy
    way out :) )

(3) Actually truncate the string and modify it's length.  This is really
    messy b/c it requires char lvalues to keep a pointer to the start as
    well, and also is somewhat counterintuitive.

---

One can call private functions in inherited objects via call_out.

---

heart_beats() doesn't obey set_hide()

---

verbs that no longer have handlers should be deleted from the parser list

---

Line numbers can be screwed up by macro expansion.  Consider the following:

#define IGNORE(x)
#define USE_ONCE(x) x
#define USE_TWICE(x) x

// The end of the next line never gets counted.
IGNORE("foo\
bar")

// The end of the next line is counted once.
USE_ONCE("foo\
bar")

// The end of the next line is counted twice.
USE_TWICE("foo\
bar")

So the IGNORE() and USE_TWICE() cases with screw up line numbering.
Fixing this is non-trivial, since macro expansions are reinserted into
the input stream.  Outside of quotes, it was handled by replacing
'\n' with ' ' which is semantically equivalent.  Inside quotes, one has
to do something like count the newlines as they are parsed, and then
have add_input() keep track of how many artificial newlines it has created,
so these can be ignored, which requires a check every time current_line++
is done ...

There must be a better fix :)

---

({ i++, j })[1];

still wrong ?
